h1. Fudge

Fudge is a CI build tool for Ruby/Rails projects.

It allows you to:

* Define your CI build process in a Ruby DSL.
* Keep your build definition in your code repository and version control.
* Define different build processes for different branches of your code.
* Run common tasks including code coverage assertion.
* Define custom tasks for your build process.

h2. Installation

Add to your project's Gemfile:

    gem 'fudge', :git => 'git@github.com:Sage/fudge.git'

Run in your project root:

    bundle install

h2. Usage

To create a blank Fudgefile, run in your project root:

    bundle exec fudge init

To run the CI build (this is what you'd put in your CI server):

    bundle exec fudge build

h2. Fudgefile syntax

To define a build with a given name (or for a given branch):

    build :some_name do
    end

To define some tasks on that build:

    build :some_name do
      task :rspec, :coverage => 100
    end

Any options passed to the task method will be passed to the task's initializer.

You can also use one of the alternative method missing syntax:

    build :some_name do |b|
      rspec :coverage => 100
    end

h3. Composite Tasks

Some tasks are composite tasks, and can have tasks added to themselves, for example the each_directory task:

    build :some_name do
      task :each_directory, '*' do
        task :rspec
      end
    end

h3. Task Groups

You can define task groups to be reused later on in your Fudgefile. For example:

    task_group :tests do
      rspec
    end

    task_group :docs do
      yard
    end

    build :some_name do
      task_group :tests
      task_group :docs
    end

    build :nodoc do
      task_group :tests
    end

Task groups can take arguments, so you can make conditional task groups for sharing between build. For example:

    task_group :deploy do |to|
      shell "cp -r site/ #{to}"
    end

    build :default do
      task_group :deploy, '/var/www/dev'
    end

    build :production do
      task_group :deploy, '/var/www/live'
    end

h3. Callbacks

You can define success and failure callbacks using the following syntax:

    build :default do
      rspec

      on_success do
        shell 'deploy.sh'
      end

      on_failure do
        shell 'send_errors.sh'
      end
    end

Build will by default run WITHOUT callbacks enabled. To run a build with callbacks, run:

    bundle exec fudge build --callbacks

You can mix task_groups with callbacks however you like, for example:

    task_group :deploy do
      shell 'deploy.sh'
    end

    task_group :error_callbacks do
      on_failure do
        shell 'send_errors.sh'
      end
    end

    build :default do
      on_success do
        task_group :deploy
      end

      task_group :error_callbacks
    end

h2. Defining tasks

A task is a class that responds to two methods:

@self.name@ => A class method that returns a symbol representing the task. This is what will be used to identify your task in the Fudgefile.
@run@ => An instance method which carries out the contents of the task. Should return @true@ or @false@ depending on whether the task succeeded.

For example, here is a simple task which will print some output and always pass:

    class LoudTask
      def self.name
        :loud
      end

      def run
        puts "I WAS RUN"
        true
      end
    end

h3. Registering your task

To make your task available to Fudge, you simply register it in @Fudge::Tasks@:

    require 'fudge'
    Fudge::Tasks.register(LoudTask)

This will make the @LoudTask@ task available in your Fudgefile's like so:

    build :some_name do
      task :loud
    end
